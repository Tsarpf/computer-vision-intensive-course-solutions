
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\begin{document}
\title{Day 2}

\author{\emph{Teemu Sarapisto}}
\maketitle

\newcommand{\aaa}[3]{%
  \fbox{\includegraphics[height=30mm]{#1}} \quad
  \fbox{\includegraphics[height=30mm]{#2}} \quad
  \fbox{\includegraphics[height=30mm]{#3}} \par}
\newcommand{\bbb}[3]{%
  \medskip\noindent\aaa{#1}{#1-#2}{#1-#3}}

\newpage

\setlength{\fboxsep}{0pt}%

\section{Hands-on day 2}
Hola world

\subsection{Use OpenCV’s morphological dilation and closing with different structuring element shapes and sizes to fill in the “holes” in the strawberries. Try to also clean away the noisy stray pixels with mild erosion or opening}
    \begin{figure}[h]
        \centering
        \includegraphics[scale=0.50]{morph}
    \end{figure}

\subsection{What seems to be the best operations, structuring element shapes and their sizes? In which order were they performed?}

\begin{itemize}
    \item Closing operation with a rectangular kernel
    \item Dilation operation with a rectangular kernel
    \item Closing operation 2 with a rectangular kernel
    \item Erosion operation with a rectangular kernel
\end{itemize}

\subsection{Apply a series of OpenCV’s Gaussian blurring operations with increasing kernel sizes to get smoothed versions of the image}
Kernel sizes: 3/5 11/15 27/27 37/47

\fbox{\includegraphics[scale=0.2]{gaussed3-5}} \quad
\fbox{\includegraphics[scale=0.2]{gaussed11-15}} \quad
\fbox{\includegraphics[scale=0.2]{gaussed27-27}} \quad
\fbox{\includegraphics[scale=0.2]{gaussed37-47}} \par

\subsection{Apply OpenCV’s Laplace filtering to the blurred images}
oispa kaljaa

\fbox{\includegraphics[scale=0.2]{laplace1}} \quad
\fbox{\includegraphics[scale=0.2]{laplace2}} \quad
\fbox{\includegraphics[scale=0.2]{laplace3}} \quad
\fbox{\includegraphics[scale=0.2]{laplace4}} \par

\subsection{Analyze how the size of the detected details increases with the increasing blur size}
\fbox{\includegraphics[scale=0.2]{laplace1_zcross}} \quad
\fbox{\includegraphics[scale=0.2]{laplace2_zcross}} \quad
\fbox{\includegraphics[scale=0.2]{laplace3_zcross}} \quad
\fbox{\includegraphics[scale=0.2]{laplace4_zcross}} \par
With the increasing blur size the size of the detected details increases.:

\subsection{how long it took}
Around 4 hours

\subsection{Hands-on code}

\begin{verbatim}
  import cv2
  import numpy as np
  import matplotlib.pyplot as plt
  import matplotlib.cm as cm
  from scipy import ndimage as nd
  from scipy.spatial import distance


  # We will use the image, strawberries-binary.pbm that is a binary mask or segmentation result showing the red strawberry pixels of the previous home work

  strawberries_red = cv2.imread('strawberries-binary.pbm')

  #Read the image in and scale it to have “white” values 1 for the strawberry pixels and “black” values 0 for background pixels
  binary_strawberries = strawberries_red / 255

  #Use OpenCV’s morphological dilation and closing with different structuring element shapes and sizes to fill in the “holes” in the strawberries
  #Try to also clean away the noisy stray pixels with mild erosion or opening
  rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))
  elliptical_kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))
  cross_kernel = cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))

  closing = cv2.morphologyEx(binary_strawberries, cv2.MORPH_CLOSE, rect_kernel)

  dilation = cv2.dilate(closing, rect_kernel, iterations = 2)

  closing2 = cv2.morphologyEx(dilation, cv2.MORPH_CLOSE, rect_kernel)

  kernel = np.ones((5,5),np.uint8)
  erosion = cv2.erode(closing2, kernel, iterations = 3)

  #cv2.imshow("homma", erosion * 255)
  cv2.imwrite("morph.jpg", erosion * 255)
  #cv2.waitKey()


  ###Next we use building.tiff to study scale space filtering, Laplacian of Gaussian filtering and edge detection by zero crossings
  # Ookoo kuulostaapa hyveltä

  ###Read the image in and scale it as a single-channel (greyscale) image in range [0,1]
  building = cv2.imread('building.tiff', cv2.IMREAD_GRAYSCALE) / 255

  ###Apply a series of OpenCV’s Gaussian blurring operations with increasing kernel sizes to get smoothed versions of the image

  #cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])  dst
  gaussed1 = cv2.GaussianBlur(building, (3,5), 0)
  gaussed2 = cv2.GaussianBlur(building, (11,15), 0)
  gaussed3 = cv2.GaussianBlur(building, (27,27), 0)
  gaussed4 = cv2.GaussianBlur(building, (37,47), 0)

  cv2.imwrite('gaussed3-5.jpg', gaussed1 * 255)
  cv2.imwrite('gaussed11-15.jpg', gaussed2 * 255)
  cv2.imwrite('gaussed27-27.jpg', gaussed3 * 255)
  cv2.imwrite('gaussed37-47.jpg', gaussed4 * 255)

  #Apply OpenCV’s Laplace filtering to the blurred images
  #When saving the Laplace images for the report, multiply them with a proper constant, add 0.5 and clip to [0,1] to improve their informativeness
  def clip(i):
      return np.clip(i, 0, 1)

  kernel_size = 3
  scale = 1
  delta = 0
  laplace1 = cv2.Laplacian(gaussed1, cv2.CV_64F)
  laplace2 = cv2.Laplacian(gaussed2, cv2.CV_64F)
  laplace3 = cv2.Laplacian(gaussed3, cv2.CV_64F)
  laplace4 = cv2.Laplacian(gaussed4, cv2.CV_64F)

  cv2.imwrite('laplace1.jpg', clip(laplace1 * 40 + 0.5) * 255)
  cv2.imwrite('laplace2.jpg', clip(laplace2 * 40 + 0.5) * 255)
  cv2.imwrite('laplace3.jpg', clip(laplace3 * 40 + 0.5) * 255)
  cv2.imwrite('laplace4.jpg', clip(laplace4 * 40 + 0.5) * 255)

  #Write your own function to detect zero crossings (aka sign changes) in the Laplace filtered images
  ###Compare each pixel value’s sign (-1, 0 or +1) to that of the neighboring pixel on the left and above: If all signs are equal, the pixel is not a zero crossing pixel, otherwise it is

  def zero_cross(A):
      new = np.zeros(A.shape)
      for x in range(A.shape[1]):
          for y in range(A.shape[0]):

              if x == 0 and y == 0: 
                  new[y][x] = 0
              elif x == 0:
                  if np.sign(A[y][x]) != np.sign(A[y][x-1]):
                      new[y][x] = 1
                  else:
                      new[y][x] = 0 
              elif y == 0:
                  if np.sign(A[y][x]) != np.sign(A[y-1][x]):
                      new[y][x] = 1
                  else:
                      new[y][x] = 0 
              else:
                  if np.sign(A[y][x]) != np.sign(A[y-1][x]) or np.sign(A[y][x]) != np.sign(A[y][x-1]):
                      new[y][x] = 1
                  else:
                      new[y][x] = 0
      return new


  zbuilding = zero_cross(building)
  #print(zbuilding[23])

  #cv2.imwrite('zero_building.jpg', zbuilding)

  #Mark the zero crossing pixels with red color in the images
  def color_zero(zero_cross, original):
      original_uint8 = np.array(original, dtype=np.uint8)
      new = cv2.cvtColor(original_uint8,cv2.COLOR_GRAY2BGR)
      for x in range(zero_cross.shape[0]):
          for y in range(zero_cross.shape[1]):
              if zero_cross[x,y] == 1:
                  new[x,y] = [0,0,255]
              else:
                  new[x,y] = original[x,y]
      
      return new

  #cv2.imshow('haloo', color_zero(zbuilding, building))
  #cv2.waitKey()
      

  #Analyze how the size of the detected details increases with the increasing blur size
  laplace1_cross = zero_cross(laplace1)
  laplace2_cross = zero_cross(laplace2)
  laplace3_cross = zero_cross(laplace3)
  laplace4_cross = zero_cross(laplace4)
  cv2.imwrite('laplace1_zcross.png', color_zero(laplace1_cross, clip(laplace1 * 40 + 0.5) * 255))
  cv2.imwrite('laplace2_zcross.png', color_zero(laplace2_cross, clip(laplace2 * 40 + 0.5) * 255))
  cv2.imwrite('laplace3_zcross.png', color_zero(laplace3_cross, clip(laplace3 * 40 + 0.5) * 255))
  cv2.imwrite('laplace4_zcross.png', color_zero(laplace4_cross, clip(laplace4 * 40 + 0.5) * 255))
  #cv2.waitKey()
  #Report again how long it take to complete these assignments
\end{verbatim}

\section{Homework}
\subsection{Maximum Strawberry Finder Professional Edition}
\fbox{\includegraphics[scale=0.5]{max_mansikkuus}} \quad

\subsection{We try to find airport runways in image marion\_airport.tiff. Use OpenCV Canny edge detector function to find edges in the image}
%\subsection{We try to find airport runways in image marion}


\fbox{\includegraphics[scale=0.3]{canny1}} \quad
\fbox{\includegraphics[scale=0.3]{canny2}} \quad
\fbox{\includegraphics[scale=0.3]{canny3}} \quad
\fbox{\includegraphics[scale=0.3]{canny4}} \par

second row first image, canny3, was best, it was created with params 400, 500 below:
\begin{verbatim} 
canny1 = cv2.Canny(airport, 100, 200)
canny2 = cv2.Canny(airport, 200, 300)
canny3 = cv2.Canny(airport, 400, 500)
canny4 = cv2.Canny(airport, 500, 600)
\end{verbatim}


\subsection{Use OpenCV’s Hough line transform function to detect the runway pixels
experiment with the parameter values to get a good result}
\fbox{\includegraphics[scale=0.3]{hough-100-5-50}} \quad
\fbox{\includegraphics[scale=0.3]{hough-10-10-10}} \quad
\fbox{\includegraphics[scale=0.3]{hough-1000-27-100}} \quad
\fbox{\includegraphics[scale=0.3]{hough-1000-1-100}} \par


\subsection{Explain the meaning of the parameters of both the Canny and Hough implementations in OpenCV}
Canny parameters are low and high thresholds for determining whether the edge at a pixel is a 'weak' or 'strong' one, by comparing whether the gradient at that pixel is under/over the low/high thresholds respectively.


rho – Distance resolution of the accumulator in pixels.
\begin{verbatim} rho - Distance resolution of the accumulator in pixels. \end{verbatim}
  Maybe how far the cells are looked for in the accumulator? Not sure.

\begin{verbatim} theta - Angle resolution of the accumulator in radians. \end{verbatim}
  I'm guessing this is for setting how circle'y curves are searched for

\begin{verbatim} threshold - Accumulator threshold parameter. Only those lines are returned that get enough votes ( >\texttt{threshold} ). \end{verbatim}
  Sets how many grid cells must a curve match with the image for it to count as a found curve.




I'm not sure what the other are
\subsection{Would it be possible to make the parameter value selection automatic or is human inspection necessary?}
For Canny there is Otsu's Method for selecting the thresholds.  

For Hough at least some of the parameters have to be locked while searching for the others, for example fixing the size of a circle that is being searched for.

\subsection{Time used}
Around 4 hours

\subsection{Homework code}
\begin{verbatim}
  import cv2
  import numpy as np
  import matplotlib.pyplot as plt
  import matplotlib.cm as cm
  from scipy import ndimage as nd
  from scipy.spatial import distance

  print(cv2.__version__)


  # Implement integral image iif(x,y) and apply it to strawberries-binary.pbm after scaling it to a binary image

  def summed_area_table(A):
      new = np.full((A.shape[0] + 1, A.shape[1] + 1), 0)
      print(new.shape)
      for x in range(A.shape[0]):
          if x == 0: continue
          for y in range(A.shape[1]):
              if y == 0: continue
              new[x,y] = new[x,y-1] + new[x-1,y] + A[x,y] - new[x-1,y-1]
      return new

  def iif(x0, y0, x1, y1, A):
      return A[x1,y1] - A[x1, y0 - 1] - A[x0 - 1, y1] + A[x0 - 1, y0 - 1]

  strawberries_red = cv2.imread('strawberries-binary.pbm', cv2.IMREAD_GRAYSCALE)

  #Read the image in and scale it to have “white” values 1 for the strawberry pixels and “black” values 0 for background pixels
  binary_strawberries = strawberries_red / 255

  #print(iif(0,1, binary_strawberries))
  def get_max(A):
      table = summed_area_table(A)
      #result = np.zeroes((A.shape[0] - 100, A.shape[1] - 100))
      max = 0
      max_pos = (0,0)
      for x in range(A.shape[1] - 100):
          for y in range(A.shape[0] - 100):
              area_sum = iif(x, y, x + 100, y + 100, table)
              #result[x,y] = area_sum
              if area_sum > max:
                  max = area_sum
                  max_pos = (x,y)
      
      return max_pos

  max_pos = get_max(strawberries_red)

  strawberries_color = cv2.imread('strawberries_color.jpg')
  rectangled = cv2.rectangle(strawberries_color, (max_pos[1], max_pos[0]), (max_pos[1]+100, max_pos[0]+100), (0,0,255), 3)

  cv2.imwrite('max_mansikkuus.jpg', rectangled)
  cv2.waitKey()



  #We try to find airport runways in image marion_airport.tiff
  #Use OpenCV’s Canny edge detector function to find edges in the image
  #edges relating to the runways should be found as much as possible and the others as little as possible
  #experiment with the parameter values to get a good result
  #include in the report some different outcomes

  def add_edges(edges, airport_rgb):
      new = np.copy(edges)
      for x in range(edges.shape[0]):
          for y in range(edges.shape[1]):
              if np.all(edges[x,y] != 0):
                  edges[x,y] = [0,255,0]
                  new[x,y] = [0, 0, 255]
              else:
                  new[x,y] = airport_rgb[x,y]
      return new

  airport = cv2.imread('marion_airport.tiff', cv2.IMREAD_GRAYSCALE)
  airport = np.uint8(airport)

  canny1 = cv2.Canny(airport, 100, 200)
  edges1 = cv2.cvtColor(canny1, cv2.COLOR_GRAY2RGB)
  canny2 = cv2.Canny(airport, 200, 300)
  edges2 = cv2.cvtColor(canny2, cv2.COLOR_GRAY2RGB)
  canny3 = cv2.Canny(airport, 400, 500)
  edges3 = cv2.cvtColor(canny3, cv2.COLOR_GRAY2RGB)
  canny4 = cv2.Canny(airport, 500, 600)
  edges4 = cv2.cvtColor(canny4, cv2.COLOR_GRAY2RGB)

  airport_rgb = cv2.cvtColor(airport, cv2.COLOR_GRAY2RGB)
  canny1out = add_edges(edges1, airport_rgb)
  canny2out = add_edges(edges2, airport_rgb)
  canny3out = add_edges(edges3, airport_rgb)
  canny4out = add_edges(edges4, airport_rgb)

  cv2.imwrite('canny1.png', canny1out)
  cv2.imwrite('canny2.png', canny2out)
  cv2.imwrite('canny3.png', canny3out)
  cv2.imwrite('canny4.png', canny4out)


  #Use OpenCV’s Hough line transform function to detect the runway pixels
  #experiment with the parameter values to get a good result
  #include in the report some different outcomes

  def houghify(minLineLength, maxLineGap, threshold, canny, A):
      image = np.copy(A)
      lines = cv2.HoughLinesP(canny, 1, np.pi/180, threshold, minLineLength, maxLineGap)
      for line in lines:
          for x1,y1,x2,y2 in line:
              cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 5)
      return image

  #minLineLength = 1000
  #maxLineGap = 1
  #threshold = 40

  cv2.imwrite('hough-100-5-50.jpg', houghify(100, 5, 50, canny3, airport))
  cv2.imwrite('hough-10-10-10.jpg', houghify(10, 10, 10, canny3, airport))
  cv2.imwrite('hough-1000-27-100.jpg', houghify(1000, 27, 100, canny3, airport))
  cv2.imwrite('hough-1000-1-100.jpg', houghify(1000, 1, 100, canny3, airport))

  #cv2.imwrite('hough.jpg', airport)

\end{verbatim}


\end{document}
%  LocalWords:  Jorma Laaksonen pdf py tex OpenCV libopencv dev jpg
%  LocalWords:  highgui imgproc imgcodecs greyscale png opencv ing
%  LocalWords:  texlive includegraphics Exactum Gür Ersalan
